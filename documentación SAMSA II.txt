
10-4-11

IMPROVEMENTS realizados:

- batería independiente para la parte de 5V
- arreglada la fruta en las caminatas. (sigue siendo imprecisa la velocidad)
- confirmado: la "cagatta" en el movimiento se debe a la fuente de alimentación
- sensor de cuerdita terminado e instalado
- solucionado tema de choque involuntario de patas
- solucionado totalmente (se supone) el cambio de dirección "on the fly"
- corregida la IK, que daba error en rotaciones muy cerradas del tronco
- modo para editar la posición (hexágono)
- se independizó la variable "step" en las caminatas y los movs. del cuerpo
- se sacó de los .h todo aquello que no era público
- "cabeza" es ahora una clase, y se creó otra clase "remote control"
- se implementaron (parcialmente) las "páginas" en el menu del RC
- se implementó el modo "editar centro"
- y también los 3 modos de oscilaciones, aunque con algunas carencias
- ciertas correcciones en el cálculo de altura_pasitos
- primer esbozo de poll_load


1) TO DO INMEDIATO

- con el poll load, se puede detectar:
  - empujes en varias direcciones
  - levantado de pata individual
  - consumo total
- hay un bug: al cambiar de dirección sobre la marcha, habiendo previamente "acelerado"
  con la escala, el robot se hunde misteriosamente
- revisar y refinar todo lo que es la interfaz usuario
- hacer "macros" de color
- ojo con la altura de los pasitos, que salta alguna fruta de vez en cuando --> se está arreglando
- hacer un modo 'test_sensor'
  que testee las 5 cosas de la cabeza, el sensor de cuerdita y el de empuje
- hacer un "test battery" 
- hacer "macros" para la 'oscilador' (por ejemplo: círculos, etc.)
- extender la display con más cosas dinámicas
  - triángulos
  - animación con líneas encadenadas (nibbles, de longitud variable y multicolores)
  - color scroll, plasma, línea que se mueve, objeto que se mueve, caracter que se mueve
  - scroll, rotaciones, etc. en versión animada
  - cambio de modo de color y de color mismo, automáticos
  - la medidor, en versión animada (usar punteros a las variables de la caminata, o viceversa)
  - la display tendría una función "monitorear x" y se le pasa un puntero a algo
  - por ejemplo, un "piano roll" de patas apoyadas, el "gait monitor", el load monitor
  - mostrar textos en más de 1 color
- rutinas de la cabeza para seguir objetos (ver robotito)
- rutinas de la cabeza: movimientos (ver robotito; implementar con timer igual que el resto)
- interfaz usuario para operar desde el control remoto IR
	// monitorear:
		- lectura sensores
		- temperatura
		- voltaje
		- tiempo de encendido
		- uso del CPU  
                - consumo motores      
        // modo para mover la cabeza
	// uno de los botones de arriba, que vuelva realmente al origen (al punto de partida)
	// implementar un timeout para que vuelva lentamente a la posición 
           (o para que pase al modo autónomo)
	// 2 colores en los mensajes (implementar en la display)
	// "auto" en los parámetros que lo tienen
        // ingresar valores con el teclado numérico
	// y en todos los modos, una manera de incrementar y decrementar rápida!
	// que la altura del pasito también se pueda ajustar, además de dejar en AUTO
	// tecla de reset y tecla de random en modo osciladores
	// tecla para volver al origen en modos de rotaciones y traslaciones, sin saltar
	// lo mismo, pero que lo haga con damped oscilations (la frecuencia de las
	   oscilaciones seria a que ya está seteada, y hay que ver qué pasa con la fase)
- comunicación bluetooth, acelerómetro remoto
- el salto (con la bezier)
- conductas: que se mantenga siempre a una distancia fija del objeto, autónomo,
             que siga a un objeto que se mueve, etc.
             conducta autónoma básica, avoid obstacles

2) IDEAS 

- que escriba, con un lápiz en la cabeza
- control remoto con acelerómetro y con sensores hechos a motor de HD
- módulo de audio con ANN igual que SAMSA I (en arduino mini)
- módulo para generar audio, con chip vs (y probar de capturar audio también)
- baile: robotito + fractal rhythm + linear rhythm
- baile sincronizado con robotito (fácil, usando el receptor IR. Hay que sincronizarse al beat)
- sensores en las patas. 
- GRAN IDEA: hackear los motores del último anillo para conectar los sensores en ellos
- polling de 'load' de los motores, y procesar esta información
- idea: un touchscreen arriba del display
- la chotada con las patas de adelante es casi obligatoria
- subir escaleras??
- acelerómetro en el propio robot, conducta: que el cuerpo quede siempre horizontal
- manejar los leds de los ax12
- idea: agendar movimientos relativos durante la caminata, a ver qué pasa
- movimiento individual de cada pata, cuando la agarran
- que arranque a caminar cuando lo empujan / en la dirección que lo empujan
- o que se incline y luego vuelva a la posición como un resorte, e incluso que quede oscilando
- esto introduce un nuevo concepto: "damped" oscilations
- las oscilaciones deberian tener envolvente
- que detecte choques de la misma manera
- que aprete cosas en el piso, botones, luces, ruidos, etc
- que visualice, con movimientos y/o con el display, música

3) MEJORAS

- HARDWARE: método para apagar el led IR que consume mucho
  (comando para apagar el led del sensor inteligente)
- otros ahorros de energía y optimizaciones (sobre todo de tiempo)
- caminata:
  - los pasitos deberían ser no tan verticales
  - aleatorizar: 1) puntos de aterrizaje de las patas 
                 2) secuencia 
                 3) regularidad temporal
  - pasos automáticos basados en la posición de las patas, el peso, etc.
  - que utilize los sensores para caminar en terrenos irregulares
  - controlar el torque de los motores, para ahorrar energía y vida útil
  - modulación de caminatas (que haga otros movimientos mientras camina)
  - secuencias de más de 6 fases, en especial irregulares (4, 8, 5, 7, 9, 10, 11, etc)
- calculating which leg is most away from its optimal position. So no fixed sequences are used.

4) CON RESPECTO AL CÓDIGO MISMO

- documentar el API
- desarduinizar el código
- sustituir la analogRead() por la versión sin delay
- poner todo lo que es hardware en hardware, lo que es util en util, etc.
- y lo que no se usa, dejarlo en un archivo todo comentado
- re-escribir todo lo del control remoto IR
- también en la clase "movimiento" hay mucho que re-escribir, hay cosas que se repiten
- ¿implementar las funciones trigonométricas con tablas??



18-3-11

che, los motores dynamixel pueden medir torque? en ese caso esa puede 
> ser la mejor solucion para calcular la direccion del tironeo... 
> kinematica inversa sobre la posicion en donde llegarian las patas si 
> les aplicaras el torque en cada motor. Es mas, ese es creo yo parte 
> del "metodo" natural que usan los bichos (propiocepcion, y por 
> supuesto sensacion tactil, pero no creo que con la sensacion sola 
> "saquen" la direccion). 
> Una version simplificada de eso, seria primero detectar que hay un 
> tironeo (basado en eso del torque, pero sin necesidad de calcular la 
> direccion), y despues hacer que el robot haga un pequeno microbaile 
> (tipo mueva la cabeza o cuerpo en uno o varios circulos), para saber 
> en donde se minimiza ese torque... 


TO DO lateral:

1) escribir artículo blog 
   a) español
   b) inglés
2) hacer dibujos que faltan
3) firmar el código y publicar
4) laburar la mbed UDP
5) laburar el encoder / evangelos 
6) liberar el encoder y hacer el sensor para la correa


2/3/2011

- implementar las rutinas que aparecen comentadas en el código
- se siguen chocando las patas al arrancar la caminata, 
  hay que hacer algo al respecto.


18/2/2011

- hay ciertas caminatas que dan fruta
  (ciertas combinaciones de 1 pata tomadas de a 3 que no funcionan)
  estudiarlo con el modelo de processing --> solucionado

- empezó otra vez el problema de la inestabilidad de los motores
  optimizar todo lo que se pueda los cálculos --> sí

- hay ciertas combinaciones de 1 pata tomadas de a 3 que dan una velocidad falsa


14/2/2011 - RESUMEN DE IDEAS Y COSAS PENDIENTES

1) TO DO INMEDIATO

- evitar que arranque una caminata cuando hay patas en el aire  --> solucionado
- ojo con la altura de los pasitos, que salta alguna fruta de vez en cuando
- para que no se tranque al arrancar: 
    no inhibir el movimiento en las patas delanteras o traseras 
    (segun el sentido del movimiento)
    o bien, verificar la distancia con la pata vecina --> arreglado, de otra manera pero arreglado
- cambiar de dirección "on the fly"  --> en los hechos, implementado
- corregir el límite angular del primer motor --> no existe!?
  corregir lo que hace que el giro sobre el eje 'y' dé cierta fruta --> arreglado, era un problema de la IK
- hacer un modo 'test_sensor'
- hacer un "test battery" -- que los motores no arranquen frenados 
- hacer "macros" para la 'oscilador' (por ejemplo: círculos, etc.)
- extender la display con más cosas dinámicas
  - triángulos
  - animación con líneas encadenadas (nibbles, de longitud variable y multicolores)
  - scroll, rotaciones, etc. en versión animada
  - cambio de modo de color y de color mismo, automáticos
  - la medidor, en versión animada (usar punteros a las variables de la caminata, o viceversa)
  - la display tendría una función "monitorear x" y se le pasa un puntero a algo
  - por ejemplo, un "piano roll" de patas apoyadas, el "gait monitor"
  - mostrar textos en más de 1 color
- rutinas de la cabeza para seguir objetos (ver robotito)
- rutinas de la cabeza: movimientos (ver robotito; implementar con timer igual que el resto)
- interfaz usuario para operar desde el control remoto IR
	// monitorear:
		- lectura sensores
		- temperatura
		- voltaje
		- tiempo de encendido
		- uso del CPU  
                - consumo motores      
        // modo para mover la cabeza
	// uno de los botones de arriba, que vuelva realmente al origen (al punto de partida)
	// implementar un timeout para que vuelva lentamente a la posición
	// modo para editar la posición (hexágono) --> ver hoja
        // modo para editar centro de rotaciones (directo x, y, z, en el display x=.., y=..., etc.)
	// modo para oscilaciones (integrado en los modos de traslación, rotación y centro
           recuerda el parámetro, ya sabe la amplitud, vol y ch son frecuencia y fase ) --> cómo??
	// 2 colores en los mensajes (implementar en la display)
	// "auto" en los parámetros que lo tienen
        // independizar la variable "step" en las caminatas y los movs. del cuerpo --> hecho
	// ingresar valores con el teclado numérico
	// mayor incremento??
- comunicación bluetooth, acelerómetro remoto
- el salto (con la bezier)
- conductas: que se mantenga siempre a una distancia fija del objeto, autónomo,
             que siga a un objeto que se mueve, etc.

2) IDEAS 

- que escriba, con un lapiz en la cabeza
- control remoto con acelerómetro y con sensores hechos a motor de HD
- módulo de audio con ANN igual que SAMSA I (en arduino mini)
- módulo para generar audio, con chip vs (y probar de capturar audio también)
- baile: robotito + fractal rhythm + linear rhythm
- baile sincronizado con robotito (fácil, usando el sensor IR)
- sensores en las patas. 
- GRAN IDEA: hackear los motores del último anillo para conectar los sensores en ellos
- polling de 'load' de los motores
- idea: un touchscreen arriba del display
- OTRA GRAN IDEA: la cuerdita para pasearlo, con sensor de fuerza y encoder
- la chotada con las patas de adelante es casi obligatoria
- subir escaleras??
- acelerómetro en el propio robot
- manejar los leds de los ax12
- idea: agendar movimientos relativos durante la caminata, a ver qué pasa
- movimiento individual de cada pata, cuando la agarran
- que arranque a caminar cuando lo empujan / en la dirección que lo empujan
- que detecte choques de la misma manera
- que aprete cosas en el piso, botones, luces, ruidos, etc

3) MEJORAS

- HARDWARE: método para apagar el led IR que consume mucho
  (comando para apagar el led del sensor inteligente)
- otros ahorros de energía y optimizaciones (sobre todo de tiempo)
- una bateria independiente para la parte de 5V
- ponerle nombre (puede ser SAMSA II)
- caminata:
  - los pasitos deberían ser no tan verticales
  - aleatorizar: 1) puntos de aterrizaje de las patas 
                 2) secuencia 
                 3) regularidad temporal
  - pasos automáticos basados en la posición de las patas, el peso, etc.
  - que utilize los sensores para caminar en terrenos irregulares
  - controlar el torque de los motores, para ahorrar energía y vida útil
  - modulación de caminatas (que haga otros movimientos mientras camina)
  - secuencias de más de 6 fases, en especial irregulares (4, 8, 5, 7, 9, 10, 11, etc)

4) CON RESPECTO AL CÓDIGO MISMO

- documentar el API
- desarduinizar el código
- poner todo lo que es hardware en hardware, lo que es util en util, etc.
- y lo que no se usa, dejarlo en un archivo todo comentado
- sacar de los .h todo aquello que no sea público --> hecho
- transformar cabeza en una clase --> hecho
- re-escribir todo lo del control remoto IR


13/2/2011

- las antiguas "mov_tronco", "mov_circular" y "mov_organico" quedaron ahora sustituidas por la versátil "oscilador", que puede hacer prácticamente todo lo que hacían esas 3 rutinas, y aun más cosas (modular el centro, por ejemplo)

- hay que hacer "macros" para la oscilador.

- investigar las teclas numéricas del control remoto IR --> hecho

- optimizar la matemática de la cinemática inversa con la nueva <math.h> --> listo

- sigue pendiente el tema de arrancar la caminata desde una posición arbitraria

- ideas para baile estilo robotito: que camine a tierra mientras 
  sacude el cuerpo en semicorcheas

10/2/2011

 - hacer una mini-PDLD: acelerómetro + arduino + BT,
   pero que sea "inteligente" que sólo mande data cuando hay un cambio en alguno de los ejes
 - o si no interfacear con un wiimote o un celular de esos con acelerómetro

Nuevas Ideas:

 - tortugarte para samsa 2
 - que interactúe con el otro robot
 - que el control remoto permita programar remotamente, con ayuda del display
   diseñar un interfaz-usuario


8/2/2011

 - arreglar el tema de la recepción serial y los comandos IR --> listo


6/2/2011

¿Querías multitasking? ¡TOMÁ!

/* HAY que testear:

  la caminata con todas sus opciones
  el display con todas sus opciones
  el módulo sensor con todas sus opciones
  etc.

*/
	
  - implementar urgente la antigua mov_oscilatorio, porque esto que está es muy triste
    aprovechar el tema de la animacion, es una papa :)
	
  - en la caminata curva no hay zancada progresiva, o sea que conviene siempre hacer
    un goto_pos_ref antes, a menos que...
	
  - idea: tanto para la "modulación" como para arrancar caminatas desde cualquier posición 
    y que lentamente se vaya acomodando la clave es: transformar pos_ref_
	 
  - extender la display con más cosas dinámicas
    que los propios movimientos generen opcionalemnte gráficos 
    o "eventos" traducibles de distintas maneras a gráficos --> esto no es necesario porque
    ambas rutinas están sincronizadas de por sí, es sólo calcular bien el "pause"
	 
	 nuevas ideas para la biblioteca gráfica:
	- triángulos
	- animación con líneas encadenadas
	- scroll, rotaciones, etc. en versión animada
	- cambio de modo de color y de color mismo, automáticos
	- la medidor, en versión animada


  - ir generando una documentación del API, para ordenar la cosa

  - desarduinizar el código (pelar partes que no se usan, reorganizar las otras)

  - volver sobre el tema del control remoto
    ir implementando una rutina para el módulo bluetooth
	
	rutinas de la cabeza?? 
	baile?
	módulo de audio?
	
	más sensores-- en las patas
	receptor de IR puede ir en la cabeza --> hecho


4/2/2011

- caminata: arreglado el tema de que marcha se incremente automáticamente
- ahora se puede hacer un modo superinteligente, en donde marcha se calcule automáticamente y largo_pasos sea proporcional a la velocidad --> hecho

- la caminata ya no usa active_delay. hay que hacer lo mismo con scroll_text --> hecho
- gracias a esto se puede intentar aquello de las "modulaciones" --> resultado negativo

- estos dos comentarios fueron cumplidos:
// que los métodos que aceptan "color" como parámetro, permitan mandarlo en r,g,b
// hacer unos defines para "modo" (de la rotaciones) y para "shape" (de la medidor) y para el "color_mode"

19/1/2011

- empezar con las rutinas de la cabeza, con los servos

- convertir la caminata, o todos los movimientos, en una clase... dentro de esa clase tendrías funciones para calcular parámetros, funciones o directamante variables para setear qué movimiento querés, y una funcioncita activa, llamémosle "micropaso" a la cual hay que llamar periódicamente para que el bicho se mueva --> hecho

- que la funcion guarde cuando le toca hacer el siguiente paso, y vos desde afuara la invoques tanto como quieras. ella cada vez chequaria esta variable, y si le llego el tiempo actuaria, y si no saldra sin hacer nada --> más que hecho

- la rutina internamente tendría como un reloj (basado en la millis() de arduino)... 

- la variable "desplazamiento" que yo usaba se podría seguir usando, no habría que cambiar nada, prácticamente.... simplemente llamás a la "micropaso" o mejor llamémosla "update" y si no hay nada que hacer no hace nada, por ejemplo, si seteaste para que caminada 1 metro, y no volviste a setear, por más que llames a la "update" no se mueve...(si ya caminó el metro, obvio)

- el main queda sólo con la conducta, y por supuesto manejar todos los sensores y los otros actuadores (cabeza, display)

- conducta: que se mantenga siempre a una distancia fija del objeto y detecte los movimientos laterales

- comando para apagar el led en el ojo electrónico, para ahorro de energía
- ping para el sensor de la cabeza
- comando para resetear el sensor de la cabeza (no tan importante)
- atencion, se han detectado fallas debidas al cuelgue de la arduino mini
- o talvez al tema del running status?
  - No. Son debido a que no se le puede mandar nada por serial a la mini antes que bootee

16/1/2011

- el ojo electrónico está casi pronto
- falta resolver la comunicación
- conductas (recoger ideas)
- efectos gráficos, la medidor, cosas con el color, fades, etc. (buscar ideas)
- el control remoto
- agregar más sensores, sensores en las patas, acelerómetro, micrófono, etc.
- y la consulta a los propios motores
- implementar movimientos graciosos, salto, baile y cosas matemáticas


11/1/2011

* todo apunta a que va a haber una 2a. placa para procesar los sensores

DATOS que debería devolver dicha placa:

- distancia absoluta, de 0 a 100cm
- velocidad de acercamiento o alejamiento, en cm/s
- si el objeto está a la derecha o a la izquierda
- gesto de pasar la mano de derecha a izquierda y viceversa
- gesto de alta frecuencia
- eventos históricos, con timestamp


7/1/2011

* para recibir data de los motores hay que deshabilitar el servicio de interrupciones periódicas
* para leer el/los sensores hay que usar la librería ADC en la interrupcion del timer2, 
  pero tratando de que no interfiera con los motores
* sensores de distancia para compensar al sharp y para detección de movimiento
* acelerómetro para sensar inclinación
* sensores en las patas
* para recibir info por el serial tiene que ser fuera de la ISR.. probar con el firmware de butiá
* y si ponemos otra arduino?
* se puede hacer otro servicio de interrupciones, con otro timer, para sensores?
* se puede también enviar data por serial/bluetooth
* para recibir IR hay que usar la rutina de lmdld y seguramente deshabilitar interrupciones
* se puede también enviar data por IR (usando la rutina que está en el robotito)
* para recibir audio... ummm, esto sí que es complicado, talvez meter otra arduino
  primero hay que acondicionar bien la señal con operacionales
* propongo hacer un mapa de cómo se va a administrar el tiempo
* por ejemplo, en la active delay se puede aprovechar para medir sensores, pero no
  para recibir data de los ax12.. esto último debe hacerse exclusivamente cuando el robot está
  detenido
* ATENCION: se puede recibir serial desde una ISR: leer manual ATmega1280 


TO DO inmediato:
  
  en la nueva caminata falta una pequeña corrección:
  el parámetro "marcha" debe ser interpretado como la mínima marcha, pero 
  cuando no es posible debe seleccionar automáticamente una marcha superior 
  para detectar que "no es posible", medir si algunos períodos dieron 0

  // poner en "cabeza" todo lo relativo a los servos y al sensor
  // implementar la lectura contínua del sensor
  // implementar los grafiketes y el movimiento de cabeza en la active delay
    // durante la scroltext puede mover la cabeza y/o cambiar de color
    // durante la caminata puede mover la cabeza y/o mostrar la medidor en pantalla
    // durante la mov_cuerpo puede mostrar el "cuadrado inercial"
  // poner una placa de i/o idéntica a la de SAMSA (acelerómetro, audio, etc.)
  // y los famosos sensores en las patas
  // resucitar la mov_tronco, mov_organico, mov_circular:
    // la mov_tronco y mov_circular pueden cambiar por una única mov_oscilatorio
  // y agregar una nueva, que sería mantener las rotaciones fijas y mover el centro
  // hay que poner sensores de corta distancia, para compensar la falencia del sharp 
     en menos de 10cm
  // implementar salto, puede ser un caso particular de goto_posicion
  // hacer un control remoto con palanquita, acelerómetro, etc., filmar y hacer un demo 
  // conectar receptor IR + módulo bluetooth, para usar el control de LMDLD 
     y el acelerómetro de LPDLD
  // empezar a estudiar el tema de usar los motores como sensores 
     (cuando el robot está detenido)
  // importar las rutinas de movimiento de cabeza y detección de movimientos del robotito
  // meter la plaquita midi/mp3?


28-12-10

-la biblioteca gráfica está quedando de puta madre
-propongo, para lo que es la cabeza, resucitar viejas rutinas del robotito
-y para el control remoto, si es IR, resucitar viejas rutinas de LMDLD
- y si es bluetooth, de LPDLD
- no olvidarse de la bailatta

23-12-10

implementar control remoto que controle todos los parámetros de caminata + rotaciones y
traslaciones estáticas

usar acelerómetro y talvez un touchscreen`

nombre: que sea uno de esos acrónimos nerdescos


7-12-10

implementar amortiguadores en las patas, con sensores de presión. La pata tiene que ser
cilíndrica, finita, centrada y de goma en la punta


*** previo a la versión v2 ***

/* mejoras, correcciones, ideas
  
  // la bezier de los pasitos en la caminata debería ser abierta en el eje x, 
     para que trabaje menos
  // caminata, aleatorizar: 
     1) puntos de aterrizaje de las patas 2) secuencia 3) regularidad temporal
  // caminata: agregar "modulación"  
  // empezar a trabajar con los otros periféricos: display, sensores, luces?
  // ir consiguiendo la batería
  // idea: meter un offset por motor
  // hay que cambiar las posiciones por defecto de los movimientos
  // revisar por qué no anda la mov_tronco
  // emprolijar lo que es el bajo nivel, agregar soporte para max_torque, evitar accidentes
  // los movimientos lentos estan muy toscos 
  // hay problemas de temblor
  // hacer caminatas de a 1 pata, de a 2 patas, y con el cuerpo inclinado o moviéndose 
     simultáneamente
  /* respecto a ese solo movimiento de 1 pata... la idea es que se haga automático,
     porque como ves, es un movimiento que lleva una pausa en el medio, y estaría 
     bueno que durante esa pausa el robot estuviera haciendo otras cosas. 
     talvez podría haber todo un subsistema de movimientos que permitiera 
     "agendar" movimientos complejos, y no sólo simples ángulos y velocidades */
  
  // mejora: setear los límites angulares. estudiar las zonas inaccesibles 
  
  /* bezier:

   implementar la "frenadita"

   nuevas ideas caminata:
   
   // irregularizar, poner una variable de aleatorización:
   // el avance puede ser más irregular
   // la secuencia 
   // las duraciones de las zancadas
   // frecuencias independientes para cada pata
   // agregar modulación 

// ver por qué chuequea a veces
// desarrollar otra caminata basada en principios distintos (auto trigger)
// que tenga en cuenta la estabilidad a la hora de levantar una pata y de decidir cuanto 
   tiempo y cuanta distancia moverla

// ver el tema de la alarma
// implementar un límite interno de posiciones inalcanzables
// mejorar la mecánica


*** antes de arrancar, ideas generales (octubre 2010)

usar ax12
que sea robusto
sensor laser
visión artificial
que atrape objetos
(bipedo) que no se caiga
que mida con los ax12 la fuerza
meterle muchos sensores de distancia en todas direcciones
y sensores capacitivos en todo el cuerpo
meterle el modulo mp3 y el de micro-sd
meterle el cassettero
la impresorita añeja?
que utilize redes neuronales
generación de música
reconocimiento de ritmo y de voz
matriz de leds rgb
arduino mega + foxboard
modular? PnP?
que tenga zigbee
probar el sensor de tubo con micrófonos
probar el mismo concepto pero para sonido propiamente dicho
control remoto con bola de los dioses, y por IR
usar mouse óptico como sensor
motor de HD como sensor

cuando detecta una fuerza en los motores, los deja libres y "escucha" el movimiento, 
así aprende a dar la patita, etc.

que escriba

posibles nombres:

filomeno
felisberto
Ataulfo
Anacleto
Pincus
Bonifacio
